<h1 style="display: flex; justify-content: center">SPJ算法实验报告</h1>

# 1. 实验分工安排

周强俊：Indexscan、投影操作算法、报告撰写

唐雨馨：Tablescan、投影操作算法、嵌套循环连接、基于排序的等值连接、基于索引的连接、报告撰写

周智淦：嵌套循环连接、基于散列的连接操作算法、报告撰写

字阳：测试方案设计、报告撰写

# 2.系统环境

系统：Ubuntu-24.04

clang版本：18.1.3

glibc版本：2.39

cmake版本：3.28.3

# 3. 实验设计与实现

## 3.1 查询处理器概述

查询处理器是数据库系统中负责数据查询和操作的核心模块。本系统采用**迭代器模型**，每个查询操作被抽象为一个算子（executor），通过调用其核心接口 `Next()` 来逐元组地获取结果。查询管理器支持一系列算子，包括：

- 数据操作算子（如插入、更新、删除）
- 扫描算子（如表扫描 `TableScan` 和索引扫描 `IndexScan`）
- 连接算子（如嵌套循环连接、基于排序的等值连接、基于散列的等值连接和基于索引的连接）

## 3.2 序列扫描（SeqScan）
### 3.2.1 SeqScan 的功能

SeqScanExecutor 实现了基于顺序扫描的查询操作，其主要功能包括：

- 遍历表中的所有记录，逐条扫描。
- 根据提供的条件过滤数据，返回满足条件的记录。
- 支持多条件的逻辑组合与查询。
- 确保结果符合用户定义的查询谓词（predicate）。

### 3.2.2 设计思路

#### 3.2.2.1 表和条件的初始化

`SeqScanExecutor` 的构造函数中完成了表元数据与扫描条件的初始化：

- **表元信息加载**：通过 `sm_manager_` 获取目标表的元数据，包括表的字段、模式（Schema）、字段偏移等。
- **条件加载**：将用户传入的查询条件 (`conds`) 存储在内部变量中，并支持子查询条件的延迟解析。

#### 3.2.2.2 扫描器初始化

`beginTuple()` 是扫描的入口点，主要完成以下操作：

- **初始化扫描器**：通过 `RmScan` 创建表的记录扫描器，用于顺序遍历表中的记录。
- **跳过不符合条件的记录**：调用 `predicate()` 判断记录是否满足查询条件，对不满足的记录调用 `scan_->Next()` 跳过，直至找到第一条符合条件的记录。

#### 3.2.2.3 记录遍历

`nextTuple()` 函数用于遍历记录：

- 每次调用时，通过 `scan_->Next()` 获取下一条记录。
- 调用 `predicate()` 对记录进行过滤，跳过不符合条件的记录，直到遍历结束。

#### 3.2.2.4 条件过滤

`predicate()` 函数用于检查当前记录是否满足查询条件：

- **支持多条件组合**：逐一遍历条件列表，所有条件均满足时返回 `true`，否则返回 `false`。
- **值比较**：从当前记录中提取条件字段的值，并与条件值进行比较，根据条件操作符（如 `=`、`>` 等）判断是否满足。

### 3.2.3 设计特点

1. **灵活的条件支持**
   - 支持简单的条件过滤，如字段值比较（=、>、< 等）。
   - 支持子查询条件（如 `IN`、`=` 等），并在运行时动态解析子查询结果。
2. **高效的顺序扫描**
   - 使用 `RmScan` 遍历表中的所有记录，避免不必要的复杂操作。
   - 在扫描过程中即时过滤记录，减少不必要的存储访问。

-------

## 3.3 索引扫描（IndexScan）

### 3.3.1 IndexScan 的功能

`IndexScanExecutor` 是实现基于索引的扫描算子，其主要功能包括：

- 利用索引快速定位满足条件的记录范围。
- 高效执行单点查询和范围查询。
- 支持多列索引的条件解析。
- 确保扫描结果满足查询条件。

### 3.3.2 设计思路

#### 3.3.2.1 条件解析与范围确定

`IndexScanExecutor` 的 `beginTuple()` 函数是索引扫描的入口点，首先确定索引扫描的上下界范围：

- **索引信息加载**：通过 `sm_manager_` 获取当前表和字段的索引元信息，以及对应的 `IndexHandle`。
- **初始化键缓冲区**：根据索引字段总长度初始化两个缓冲区 `key_lower` 和 `key_upper`，分别表示索引扫描的下界和上界。
- **预计算列偏移与长度**：对于多列索引，系统预先计算每列的偏移和长度，便于后续快速构造键值。

#### 3.3.2.2 条件解析与键值映射

针对查询条件（如 `OP_EQ`、`OP_GT` 等），通过以下逻辑构造索引扫描的范围：

- **等值条件** (`OP_EQ`)：将条件值填充到 `key_lower` 和 `key_upper`，通过索引的 `LowerBound` 和 `UpperBound` 获取范围。
- **范围条件**（如 `OP_GE`、`OP_LE`）：根据条件类型构造单侧边界。
- **多列索引支持**：对于多列索引，逐列解析条件并修改相应的键值偏移。

#### 3.3.2.3 初始化扫描器

利用解析后的上下界范围，初始化 `IxScan` 对象：

- `IxScan` 封装了索引节点的遍历功能，支持从叶节点的下界开始扫描至上界。
- `IxScan` 返回的每个元组对应一个 `RID`，指向表文件中的具体记录。

#### 3.3.2.4 条件过滤

由于索引范围可能较宽，实际扫描时需要对结果进行条件过滤：

- 逐步调用 `scan_->Next()` 获取下一个元组。
- 判断当前元组是否满足查询条件（通过 `predicate()`）。
- 跳过不满足条件的记录，继续扫描。

### 3.3.3 设计特点

- **灵活的条件解析**：支持单列和多列索引的条件组合。
- **高效的范围扫描**：通过 B+ 树的边界定位功能快速缩小扫描范围。

----

## 3.4 映射算子
### 3.4.1 Projection 的功能

`ProjectionExecutor` 实现了投影操作，即对查询结果进行字段选择的功能。其主要功能包括：

- 根据用户指定的字段列表（`sel_cols`），从输入元组中提取相应的字段。
- 支持字段重命名与聚合操作，如 `MAX`、`MIN`、`COUNT` 和 `SUM` 等。
- 返回投影后的结果，每次执行 `Next()` 时返回一个新的元组。

### 3.4.2 设计思路

#### 3.4.2.1 投影初始化

`ProjectionExecutor` 的构造函数初始化了投影操作所需的各项信息：

- **选择字段的解析**：根据输入的字段列表（`sel_cols`），计算并保存每个字段的偏移量、名称及其存储大小。
- **Schema 构造**：通过 `schema_` 构造新的记录模式（Schema），以便后续从输入元组中提取投影字段。
- **字段偏移计算**：为每个投影字段分配相应的存储偏移，确保按正确顺序存储投影结果。

#### 3.4.2.2 记录投影

投影过程通过 `projectRecord()` 方法完成，主要步骤如下：

- **元组获取**：从父节点（`prev_`）获取当前记录（元组）。
- **投影操作**：使用 `KeyFromTuple()` 将输入元组映射到新的记录中，选取用户指定的字段并按指定顺序返回。

#### 3.4.2.3 投影迭代

`beginTuple()` 和 `nextTuple()` 分别用于初始化投影操作和获取下一个符合条件的元组：

- **初始化**：调用 `prev_->beginTuple()` 初始化父节点的扫描，并获取第一条投影记录。
- **迭代**：每次调用 `nextTuple()` 时，从父节点获取下一条记录，并执行投影操作，直到遍历完所有记录。

### 3.4.3 设计特点

1. **灵活的字段选择**
   - 投影操作支持用户自定义的字段选择，能够灵活选择所需字段，并根据需求支持字段重命名。
   - 支持聚合操作，能够在投影阶段计算如最大值、最小值、计数、总和等统计值。
2. **高效的字段映射**
   - 使用 `KeyFromTuple()` 方法将父节点的元组映射到投影记录中，高效地从输入元组中提取指定的字段。
   - 通过 `sel_ids_` 保存投影字段在输入元组中的位置，以便在投影时快速访问相应的字段值。
3. **扩展性**
   - 设计上支持进一步扩展，可以轻松添加更多的字段选择与聚合操作。

----

## 3.5 嵌套循环连接

### 3.5.1 嵌套循环连接（Nested Loop Join）的功能

`NestedLoopJoinExecutor` 实现了数据库中的 **嵌套循环连接（Nested Loop Join）** 操作，它通过枚举左表（left table）和右表（right table）中的每一条记录，查找符合条件的记录对，最终返回连接后的结果。其主要功能包括：

- 遍历两个表中的每一条记录并进行比较，满足连接条件的记录对将被合并。
- 支持多条件的连接操作，并且可以处理左右表的不同连接条件（例如 `=`、`!=`、`<`、`>` 等）。
- 支持排序连接，当连接条件涉及到排序时，使用合适的排序方式优化查询。

### 3.5.2 设计思路

#### 3.5.2.1 初始化

`NestedLoopJoinExecutor` 的构造函数初始化了连接操作所需的各种参数：

- **左表和右表的初始化**：通过传入两个 `AbstractExecutor`（分别代表左表和右表），并从中获取表的名称、记录的长度（`left_len_` 和 `right_len_`）以及表的字段（`schema_`）。
- **连接条件的解析**：在连接条件（`fed_conds_`）中，主要处理等号连接条件（`OP_EQ`），并确定左右表中参与连接的列。若条件满足，记录连接列的元数据（`left_sel_colu_` 和 `right_sel_colu_`）。在需要排序的情况下，构建 `MergeSorter` 来处理左表的排序。
- **记录缓冲区**：为避免每次都访问底层数据，`left_buffer_` 和 `right_buffer_` 缓存了左表和右表的所有记录。

#### 3.5.2.2 嵌套循环连接的执行过程

连接过程由以下几个步骤组成：

- **beginTuple()**：在此方法中，左表和右表的所有记录会被加载到缓冲区（`left_buffer_` 和 `right_buffer_`）。接着，初始化连接的索引（`left_idx_` 和 `right_idx_`）。然后调用 `iterate_helper()` 方法开始遍历并尝试寻找符合连接条件的记录对。
- **nextTuple()**：用于获取下一对符合条件的连接记录。如果左表的记录被遍历完，`left_idx_` 会被重置为0并移动到右表的下一条记录，直到所有记录都被检查过。
- **iterate_helper()**：核心的迭代逻辑，负责遍历左表和右表的记录，并根据连接条件判断是否符合连接规则。若找到符合条件的记录，返回连接后的记录。
- **sorted_iterate_helper()**：在排序连接模式下使用，负责基于连接条件中的列值进行排序并逐步检查左右表的记录是否匹配。

#### 3.5.2.3 连接结果的合并

当找到符合条件的记录对时，`concat_records()` 会将左表和右表的记录合并为一个新的元组（`Tuple`）。合并后的记录被返回作为连接的结果。

### 3.5.3 设计特点

1. **嵌套循环连接实现**
   - 通过遍历左表和右表的每一条记录，并在符合连接条件时返回连接结果。对于每一对候选记录，都执行连接条件的判断，保证连接的正确性。
2. **支持复杂的连接条件**
   - `predicate()` 方法支持多种类型的连接条件，如等值连接（`OP_EQ`）、不等连接（`OP_NE`）、大小关系（`OP_LT`、`OP_GT` 等）。该方法通过比较左表和右表的列值来判断连接条件是否成立。
3. **排序优化**
   - 在处理涉及排序的连接条件时，`sorted_iterate_helper()` 方法能够对左表的记录进行排序优化，确保在匹配条件时能够提高性能。该选项可以自定义。
4. **高效的内存管理**
   - 使用缓冲区（`left_buffer_` 和 `right_buffer_`）缓存所有记录，避免每次都访问底层存储。通过合理的内存管理（如 `buffer_record_count`、`block_size`）确保连接操作在内存消耗方面的高效性。

### 3.5.4 连接条件的处理

`NestedLoopJoinExecutor` 处理连接条件的方式非常灵活，支持基于表中的列进行连接，并支持列与常数之间的比较。`predicate()` 方法中使用了各种比较运算符（如 `OP_EQ`、`OP_NE` 等）来实现条件判断。当连接条件中涉及表列时，系统会根据列的元数据提取对应的值进行比较；当涉及常数时，常数值直接与表列中的值进行比较。

---

## 3.6 归并连接

`MergeJoinExecutor` 是一个高效的执行器，利用 **Merge Join** 算法进行表的连接操作。它通过选择是否使用索引来优化执行路径，使用排序器对数据进行排序并高效地完成连接。它通过合理设计缓冲区、排序器和迭代器，使得在处理大量数据时能够高效地执行连接操作。

这种执行器设计不仅可以处理大规模的数据集，还能根据实际的查询优化策略，动态选择是否使用索引，确保数据库查询的性能和响应速度。

### 3.6.1 结构与功能

`MergeJoinExecutor` 是一个用于执行 **Merge Join** 算法的类，该算法通常用于两个有序集合的连接。`MergeJoinExecutor` 的核心思想是通过对两个输入数据集进行排序，然后按照指定的条件合并它们的记录。这个类是数据库引擎中的执行计划一部分，负责从查询中获取连接操作的执行步骤。

#### 3.6.1.1 构造函数 (MergeJoinExecutor)

构造函数接收四个参数：

1. `left` 和 `right`：分别是左表和右表的执行器，它们将提供需要连接的记录。
2. `conds`：包含连接条件的条件列表，通常会包括相等条件（`OP_EQ`），即基于某列的值进行连接。
3. `use_index`：一个布尔值，指示是否在连接操作中使用索引。如果为 `true`，则会通过索引加速查找。

构造过程中，`MergeJoinExecutor` 初始化了一些字段，如连接条件、左表和右表的模式（`Schema`）以及连接后结果的长度（`len_`）。接下来，它会根据连接条件确定要连接的列（即通过 `lhs_col` 和 `rhs_col` 确定）。同时，根据是否使用索引的选择，初始化排序器。

#### 3.6.1.2 核心方法

1. **`beginTuple()`**：
   - 初始化连接操作之前，检查是否使用索引。如果使用索引，首先将左表和右表的记录加载到缓冲区中。如果不使用索引，则需要先对左表和右表的记录进行排序，然后初始化排序器。
   - 调用 `nextTuple()` 启动第一次记录提取。
2. **`nextTuple()`**：
   - 判断是否使用索引。如果使用索引，调用 `index_iterate_helper()` 进行索引的连接。如果没有索引，则通过 `iterate_helper()` 进行标准的迭代连接。
   - 在连接的过程中，当找到了匹配的记录后，会通过 `concat_records()` 将匹配的记录合并成一个新的记录。
3. **`iterate_helper()`**：
   - 这是一个标准的合并连接的实现。通过排序后的数据流进行左右表记录的迭代，依次比较左表和右表的连接列的值：
     - 如果值相等，则继续合并记录。
     - 如果左表的值小于右表的值，则移动左表指针。
     - 如果右表的值小于左表的值，则移动右表指针。
   - 该过程重复进行，直到找到了匹配的记录或两个表中的一方迭代结束。
4. **`index_iterate_helper()`**：
   - 这是使用索引优化后的迭代方法，针对左右表的记录进行缓冲区中的迭代，通过索引加速查找过程。
5. **`concat_records()`**：
   - 在左右表记录匹配时，调用此方法将左表和右表的记录合并成一个新的记录。返回的是 `Tuple` 类型对象。
6. **`predicate()`**：
   - 判断当前左右表记录是否符合给定的连接条件。通常是基于列值进行比较（如相等、大小等）。

### 3.6.2 设计思路

执行流程如下：数据从两个输入表（左表和右表）传入，通过缓冲区和排序器处理，然后通过迭代器进行访问，最终返回连接后的结果。具体操作过程如下：

- 通过排序器对左表和右表的记录进行排序。
- 在迭代过程中，根据连接条件（如 `lhs_v == rhs_v`）比较左右表的记录，匹配时将结果记录合并输出。
- 每次找到一组匹配的记录后，调用 `concat_records()` 方法将左右记录合并。

### 3.6.3 优化与索引使用

`MergeJoinExecutor` 的一个关键优化是可以选择是否使用索引来加速连接操作。当 `use_index_` 设置为 `true` 时，执行器会在连接操作过程中通过索引加速记录的查找，从而减少不必要的迭代操作。当 `use_index_` 设置为 `false` 时，执行器会使用标准的 **Merge Sort** 算法对数据进行排序。

- **Merge Sort**：在数据量较大的情况下，排序能显著提高连接操作的效率。通过 `MergeSorter`，`MergeJoinExecutor` 将会对左右表进行排序并构建合并树，然后高效地进行合并操作。

-------

## 3.7 哈希连接

### 3.7.1 概述

哈希连接是关系数据库系统中的连接算法之一，特别适用于大规模数据集的等值连接操作。`HashJoinExecutor` 是本系统中实现哈希连接逻辑的核心模块，负责高效地将两个数据源（左输入和右输入）基于指定的连接条件进行匹配和组合。通过利用哈希表结构，哈希连接能够显著减少连接操作的计算复杂度，提升查询性能。

`HashJoinExecutor` 采用**迭代器模型**，与其他执行器（如扫描执行器、过滤执行器）协同工作，通过调用其核心接口 `Next()` 逐元组地获取连接结果。

### 3.7.2 哈希连接执行器（HashJoinExecutor）

#### 3.7.2.1 HashJoinExecutor 的功能

`HashJoinExecutor` 的主要功能包括：

- **哈希表构建**：从左输入数据源中提取连接键，并基于这些键构建哈希表。
- **哈希表探测**：遍历右输入数据源，通过连接键在哈希表中查找匹配的元组。
- **条件过滤**：确保连接结果满足所有指定的连接条件。
- **结果生成**：将匹配的左右元组合并为一个新的元组，作为连接结果输出。

#### 3.7.2.2 设计思路

`HashJoinExecutor` 的设计主要包括以下几个关键步骤：

##### 3.7.2.2.1 哈希表构建

- **选择合适的输入**：通常选择较小的数据源作为哈希表的构建输入（左输入），以减少内存消耗和提高缓存命中率。
- **提取连接键**：根据连接条件，从左输入的每个元组中提取用于连接的字段值，形成连接键。
- **构建哈希表**：将提取的连接键作为哈希表的键（`HashJoinKey`），对应的元组作为值，存储在 `std::unordered_multimap` 结构中，以支持键值的多重匹配。

##### 3.7.2.2.2 哈希表探测

- **遍历右输入**：逐元组遍历右输入数据源。
- **提取连接键**：从每个右输入元组中提取连接键，与哈希表中的键进行匹配。
- **查找匹配**：在哈希表中查找与右输入元组连接键相匹配的所有左输入元组。
- **生成连接结果**：对于每一个匹配的左输入元组，将其与当前右输入元组合并，生成连接结果元组。

##### 3.7.2.2.3 条件过滤

- **多条件支持**：支持等值连接。
- **谓词评估**：在生成连接结果前，对每一对候选元组应用所有连接条件，确保只有满足所有条件的元组对被输出。

### 3.7.3 详细设计

#### 3.7.3.1 构建哈希表

在连接操作的初始阶段，`HashJoinExecutor` 从左输入数据源中提取连接键，并基于这些键构建哈希表。具体步骤包括：

1. **初始化左输入**：调用左输入执行器的 `beginTuple()` 方法，开始元组的迭代。
2. **迭代左输入元组**：逐元组调用左输入的 `Next()` 方法，获取每一个元组。
3. **提取连接键**：根据连接条件，从每个左输入元组中提取指定的连接字段，形成连接键。
4. **插入哈希表**：将连接键和对应的元组插入到哈希表中，支持键的多重匹配。

#### 3.7.3.2 探测哈希表

在哈希表构建完成后，`HashJoinExecutor` 开始遍历右输入数据源，并通过连接键在哈希表中查找匹配的左输入元组。具体步骤包括：

1. **初始化右输入**：调用右输入执行器的 `beginTuple()` 方法，开始元组的迭代。
2. **迭代右输入元组**：逐元组调用右输入的 `Next()` 方法，获取每一个元组。
3. **提取连接键**：根据连接条件，从每个右输入元组中提取指定的连接字段，形成连接键。
4. **查找匹配元组**：在哈希表中查找所有与当前连接键匹配的左输入元组。
5. **生成连接结果**：将匹配的左右元组合并，生成新的连接结果元组，并通过 `Next()` 接口输出。

#### 3.7.3.3 条件过滤

在生成连接结果之前，`HashJoinExecutor` 对每一对候选元组应用所有连接条件，确保结果的准确性。具体步骤包括：

1. **遍历连接条件**：对于每一个连接条件，提取左右元组中对应的字段值。
2. **评估条件**：根据条件类型（如等值、不等、范围等），比较左右字段值，判断是否满足条件。
3. **结果验证**：只有当所有条件均被满足时，才将元组对作为有效的连接结果输出。


## 3.8 归并排序器

### 3.8.1 概述

`MergeSorter` 类是 `easydb` 数据库系统中的一个关键组件，负责实现排序操作，用于归并连接（merge join）和嵌套循环连接（nested loop join）以及后续order by子句的过程中。该类实现了一种高效的多路归并排序算法，旨在处理无法完全装入内存的大型数据集。它将数据拆分成较小的块，对每个块进行排序，然后执行最终的归并操作。

### 3.8.2 类设计

`MergeSorter` 类负责基于指定的列（键）对元组进行排序。它维护一个内存中的缓冲区来存储数据的一部分，当缓冲区满时，将已排序的数据写入临时文件。所有块排序完成后，它通过使用“败者树”结构来合并这些已排序的块，该结构能够高效地选择多路归并中的最小值或最大值。核心方法如下：

1. **构造函数:**构造函数使用指定的排序列、元组模式列、元组长度和排序顺序（升序或降序）初始化排序器。它还初始化了缓冲区、文件列表和其他必要的变量。
2. **writeBuffer(Tuple current_tuple):**该方法将一个元组添加到内存缓冲区中。当缓冲区已满时，进行排序，并将已排序的数据写入临时文件，然后清空缓冲区以准备接收更多的元组。
3. **clearBuffer():**清空当前缓冲区，排序元组后将其写入临时文件，确保所有数据在合并阶段前都已写入磁盘。
4. **initializeMergeListAndConstructTree():**初始化归并列表，通过读取磁盘上排序的块并将它们载入内存，构建败者树。败者树用于高效地归并已排序的块。
5. **IsEnd():**返回 `true` 表示所有记录已输出，归并过程已完成。它检查所有块是否已处理完毕，或者是否没有更多的记录需要归并。
6. **getOneRecord():**该方法从归并过程中获取下一条记录。它利用败者树来确定从哪个块获取记录，并推进该块的文件指针。当一个块被耗尽时，它会被标记为 `NULL`。
7. **createLoserTree():**构建败者树，败者树是一个二叉树，用于确定从哪些已排序块中获取下一个记录。树的每个叶节点对应一个块，树通过调整来确保根节点始终保存最小或最大值。
8. **adjust(int s):**该方法调整败者树，以反映每次从块中取出记录时发生的变化。对应于已获取记录的块的节点会更新为新的“赢家”，确保根节点始终保存最小或最大值。

### 3.8.3 归并排序过程

1. **初始排序：** `writeBuffer()` 方法确保数据在内存中缓冲，直到缓冲区满为止。当缓冲区满时，缓冲区中的数据会被排序并写入临时文件。这是外部排序阶段，在此阶段，数据被拆分成适合内存的较小块进行处理。
2. **归并阶段：** 所有数据被排序成块后，`initializeMergeListAndConstructTree()` 方法准备归并操作。块被读取到内存中，并构建败者树。`getOneRecord()` 方法根据当前最小或最大键值，决定从哪个块中获取下一条记录。
3. **高效的归并：** `adjust()` 方法确保每次从块中取出记录后，败者树能正确更新，以便始终从正确的块中获取下一条记录。

### 3.8.4 性能考虑

- **内存效率：** 通过使用内存缓冲区并在缓冲区满时将排序后的数据写入磁盘，`MergeSorter` 类能够处理无法完全装入内存的大型数据集。`BUFFER_MAX_SIZE` 和 `BUFFER_MAX_RECORD_COUNT` 参数可以根据不同的环境优化内存使用。
- **I/O效率：** 该类通过先在内存中排序数据然后写入磁盘，并采用多路归并技术，最大限度地减少了 I/O 操作的次数。这比简单的两路归并方法减少了读取和写入的次数。
- **败者树：** 败者树的使用优化了归并过程，减少了查找下一个最小或最大值的时间复杂度。即使在归并多个已排序块时，它也能确保归并阶段的高效性。

-----

## 3.9 查询计划示例

我们实现了实验要求的所有查询类型。本小节通过介绍各类查询的算子组织方式来阐释我们如何通过上述算子实现了实验要求 的所有查询。由于选择操作和投影操作为SQL查询中必要的操作，我们不再专门介绍。

- 嵌套循环连接 
  - `ProjectionExecutor` <-`NestedLoopJoinExecutor`<-`SeqScanExecutor`

- 基于排序的等值连接  
  - `ProjectionExecutor` <-`MergeJoinExecutor`<-`SeqScanExecutor`

-  基于散列的等值连接  
  - `ProjectionExecutor` <-`HashJoinExecutor`<-`SeqScanExecutor`

-  基于索引的连接 
  - `ProjectionExecutor` <-`NestedLoopJoinExecutor`<-`IndexScanExecutor`

对于不同连接策略的选择，我们自定义了以下字段进行索引策略选择，默认情况下，默认嵌套循环连接>排序连接>HashJoin。

```
SET enable_nestloop = false/true;
SET enable_sortmerge = false/true;
SET enable_hashjoin = false/true;
```

# 4 使用手册

## 4.1 编译

```shell
# 先进入到项目目录
cd /path/to/easydb

# 新建build目录并进入
mkdir build
cd build

# 使用cmake编译项目
cmake ..
make -j
```

## 4.2 运行

```shell
# 进入到build/bin/目录下
cd build/bin/

# 启动服务端
./easydb_server -d test.db -p 8765

# 启动客户端
./easydb_client -p 8765

# 在客户段中输入help;可以查看帮助信息
# 在客户端中执行SQL语句即可查看到执行的结果，如：
SELECT * FROM supplier WHERE S_NAME = 'Supplier#000000003';

```

![界面展示](images/1.png)

# 5 测试方案与结果

## 5.1 测试设计与实现




## 5.2 结果展示

# 6 实验总结

在本次数据库系统实验中，我们团队成功实现了一个高效且功能完备的索引管理模块。通过合理的实验分工，我们确保了每个成员都能在其擅长的领域内发挥最大的潜力。

本次实验我们主要进行了以下工作：

1. **B+树索引设计**：我们设计了B+树索引模块，通过合理的封装，实现了IxManager、IxNodeHandle、IxIndexHandle、IxScan等类，支持单点查询和范围查询，确保索引与基表数据的同步，能够进行高效的索引索引管理。

2. **可扩展哈希设计**：通过实现ExtendibleHashIxFileHdr、IxExtendibleHashIndexHandle、IxBucketHandle、IxExtendibleHashPageHdr等类，我们实现了一个可扩展哈希索引结构该索引能够动态调整目录深度并分裂目录和桶来扩展哈希表结构以适应数据量的增长，同时提高哈希冲突的处理能力，确保高效的数据插入、删除和查询操作。

3. **测试方案设计与结果验证**：我们设计了基本的测试方案，通过解析并读入supplier表格、存储数据到数据库，在此基础上，新建索引，并将数据插入到索引中，然后使用dot进行可视化，最后将索引中的某些entry删除，验证了我们实现的索引功能上的正确性。

当然我们仍旧有很多需要改进的地方：

1. **代码优化**：虽然我们已经实现了基本的功能，但在代码的优化和重构方面还有提升空间。

2. **异常处理**：在实验过程中，我们发现系统在处理异常情况时还有待加强。未来可以增加更多的异常处理机制，确保系统的稳定性和健壮性。

3. **性能测试**：本次实验主要关注了功能实现，对于系统性能的测试和优化还有所欠缺。后续可以通过对比不同配置下的性能表现，进一步优化系统设计。

4. **用户文档和接口设计**：虽然我们实现了基本的功能，但在用户文档和接口设计方面还有改进空间。可以提供更详细的用户指南和更友好的API接口，提高系统的易用性。

通过本次实验，我们不仅更加深入地理解了数据库系统的核心概念和关键技术，还提升了团队合作和项目管理的能力。未来，我们计划探索更多的数据库优化技术，如索引优化、查询优化等，进一步加强代码规范，加大测试力度，以期构建一个高效、稳定和易用的数据库系统。经过本次实验，我们对数据库系统有了更深入的理解，也为未来的学习和研究打下了坚实的基础。
